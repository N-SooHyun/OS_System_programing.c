#컴퓨터 구조와 OS#

컴퓨터 구조와 운영체제에 대해서 공부를 해볼거다.
먼저 컴퓨터 구조에 대한 간단한 얘기를 하자면

##<컴퓨터 구조 폰노이만 구조>##

폰노이만 구조의 컴퓨터구조는 아직까지도 사용하고 있는 구조이다.

1. 특정 목적을 위한 프로그램
2. 프로그램의 입력 혹은 출력데이터를 담고있는 메모리
3. 프로그램의 목적 달성을 위해 처리를 해주는 CPU
이렇게 3개로 구성이 되어 프로그램의 목적을 달성해주는것이 폰노이만의 구조이다.
정말 간단한 사칙연산 프로그램 1+2*3이라는 사칙연산 프로그램이 있다고 가정을 해보자

프로그램 = 명령어 + 데이터 로 이루어져 있다.
고로 1,2,3=데이터  +,*=명령어 임을 알 수 있으며

메모리에는 이 프로그램이 올라가게 되고
*먼저 실행해야하는 순서와 규칙을 가지고 있다.

실행순서를 보자면
1. x명령어 수행 -> cpu 2*3 = 6 -> 메모리 1+6
2. +명령어 수행 -> cpu 1+6 = 7 -> 메모리 7
3. 7 목적달성 프로그램 종료

대충 이런식이 폰노이만 구조의 방식임을 알 수 있다.

조금 더 직관적인 구조로 이번엔 요리에 관해서 예시를 들어보겠다.
라면을 끓인다고 가정을 해보자
필요한 준비물(데이터) = 면, 스프, 물, 불, 냄비 
실행 순서와 명령어
1. 냄비에 물을 넣고 불에 끓이며 기다린다. (for)
2. 물이 끓었다면 면과 스프를 넣는다. (if)
3. 면이 모두 익었다면 다 만들었다. (if),(end)
고로 이와 같을 수 있을것이다.
CPU-요리사
메모리-주방
프로그램-레시피

##<CPU의 처리단위의 발전>##
그럼 이 구조를 기억하고 오늘날 컴퓨터의 동작을 한번 유심히 살펴보자
오늘날 CPU즉 요리사는 한번 요리를 할때 32비트 혹은 64비트 만큼의 요리를 할 수 있다.
이전까지는 굉장히 간단한 1+2 혹은 면에 물을넣기 같은 한 번에 한 개의 명령어만 실행이 가능했다면
오늘날에는 32비트 넘어서 64비트 크기의 데이터를 처리할 수 있게 된것이다.
CPU가 처리할 수 있는 데이터 처리 크기는 4, 8, 16, 32, 64비트 순으로 발전을 해왔는데

1)4비트
2^4 = 16 가지의 값을 표현할 수 있었다. 즉 0&#126;15사이의 정수만을 한번에 처리할 수 있었는데
말 그대로 0000~1111까지의 표현밖에 불가능 하다는 것이었다.
그리고 CPU가 가지고 올 데이터들이 모여있는곳이 바로 메모리인데 이 메모리는 주소형태로써
CPU에게 데이터를 제공하게 되었는데 이 주소크기또한 CPU가 인지할 수 있는 4비트가 최대이다.
그래서 만약 4+5라는 프로그램을 메모리에 적재한다고 가정을 해보자
0000 = 0100(4)
0001 = 0101(5)
0010 = 0010(+덧셈 명령어)

이제 CPU는 이 메모리에 있는 데이터와 명령어들을 토대로 처리를 진행할거다.
이 데이터들을 모두 CPU내부에 있는 레지스터에 적재한다.
적재된 데이터들은 실제 연산을 해주는 ALU에 입력되어 덧셈명령어를 실행하고 출력값을 다시
레지스터에 저장하게 될것이다.
이를 토대로 메모리에 다시 출력하게 되면 프로그램은 목적을 이루고 종료될 것이다.

여기서 주의해야할점이 있다.
레지스터는 있어도 없어도 비효율적일뿐이지 연산을 못하는것은아니다.
빠른 속도로 데이터를 ALU에 넣어서 연산을할지 느리게 메모리에서 데이터를 가져와 ALU에 넣어서 연산을 할지에 차이일 뿐이다.
4비트 CPU는 스위치가 4개라고 하였지만 실제 물리적으로는 연산의 대상자 lvalue 스위치4, rvalue 스위치4, 번외로 명령어 스위치 n개로
총 물리적인 스위치의 최소 개수는 8+n개이다. 그래서 ALU에 입력대상 lvalue, rvalue라는 4비트 두 개의데이터를 입력받아서 출력이 이루어지게 된다.

그럼 8비트는 어떻겠는가? 8비트도 마찬가지로 8*2+n개의 물리적인 스위치를 최소한 가지게 될것이다.
실제 연산을 해야할 두 개의 입력 스위치와 명령어가 필요할테니까

그리고 CPU와 메모리 혹은 입출력 장치간에 통신과 데이터 교환을 위한
데이터버스와 주소버스가 있으며 
데이터 버스 = 실제 데이터를 전송하는 통로(메모리, 다른 장치)
주소 버스 = 특정 위치에 접근하기 위한 주소정보를 전송하는 통로(메모리, 다른 장치)
여기서 말하는 다른장치 = HDD,SSD | I/O 장치 | 네트워크 장치 | 그래픽 카드 등이 있다.

번외)
실제 인텔의 4비트 CPU인 4004는 주소버스가 12비트나 되었다. 이게 어떻게 가능할까?
방법은 바로 변환기에 있었다 4비트를 12비트로 매핑 변환 해주는 방식을 통해서 4비트 CPU에서도
12비트의 주소 크기를 가지고 접근이 가능하게 만들었다.

2) 32비트
2^32= 약 42억 가지 값을 표현할 수 있다.
주소크기또한 2^32 = 4기가바이트 크기만큼을 가지게된다.
이것도 마찬가지로 입력값이 최소 두 개는 필요하니
물리적인 스위치 개수는 32*2+n(명령어스위치)가 필요하다.

3) 64비트
2^64 = 약 18엑사바이트 까지의 값을 표현할 수 있다.
주소크기또한 약 18엑사바이트의 메모리 공간에 접근이 가능
이것도 물리적인 스위치 개수는 마찬가지

그러면 이론적으로 CPU의 비트 수 만큼 주소크기를 가질 수 있으며
그 주소는 CPU의 비트 최대 수 만큼 데이터 크기를 가질 수 있다.

0000 -> 0000&#126;1111  4비트
00000000 -> 00000000&#126;11111111  8비트
0x0000 -> 0x0000&#126;0xFFFF 16비트
0x00000000 -> 0x00000000&#126;0xFFFFFFFF  32비트
0x0000000000000000 - > 0x0000000000000000&#126;0xFFFFFFFFFFFFFFFF 64비트
하지만 오늘날 64비트가 올라왔다고 하더라도 메모리 주소가 가리키는 데이터의 크기는 1바이트이다.
왜 그럴까?
1. 메모리 관리의 단순화 : 1바이트로 관리하면 할당과 해제 타입의 통일된 접근이 가능해짐
2. 호환성 문제 : 과거 시스템과의 호환성을 유지하기 위해 1바이트 단위로 유지
3. 프로세서 아키텍처의 표준화 : CPU설계에서 1바이트를 기본 단위로 사용하도록 표준화되어 있기 때문 무엇보다 ALU 레지스터가 동일한 방식으로 데이터를 처리할 수 있음
4. 메모리효율성 : 1바이트로 하면 메모리 낭비를 최소화 할 수 있음
5. 데이터 정렬 및 패딩 : 현대 CPU는 데이터 정렬을 고려하여 메모리를 사용하는데 이때 1바이트 단위로 정렬되어 호환성이 높다.
6. 프로그래밍 언어의 설계 : 많은 언어에서 기본 데이터 타입을 1바이트에서 시작하도록 설계되었음
7. 하드웨어 설계 및 성능 : 메모리와 CPU간의 데이터 전송을 1바이트 단위로 수행하면 속도, 성능을 최적화 할 수 있음 또 메모리 대역폭과 CPU 클럭속도 간의 균형 유지가 좋다.

추가로 클럭이란 개념도 있는데
클럭 CPU가 1초 동안 처리할 수 있는 명령의 수
클럭 10,000Hz 1초에 10,000번의 클럭 사이클을 실행
*클럭사이클 : CPU가 특정 작업을 수행할 수 있는 시점을 결정짓는것으로 ~클럭사이클이 돌았다는건 ~시간이 걸림을 의미, 모든 명령이 한번의 클럭 사이클에 포함되는건 아님 복잡한건 여러 사이클이 돌 수 있음
*클럭주파수 : 1초에 발생하는 사이클의 수를 의미
*명령어와 클럭사이클 : 다양한 명령어를 처리함에 있어 클럭사이클수는 다를 수 있음
CPU 클럭사이클수 = 명령어 수 * 명령어당 평균 클럭 사이클 수 로 계산이 가능









